
# Python bindings for Halide

from cHalide import *               # The direct wrapper of the C++ code generated by SWIG
import numpy
import Image as PIL
import os
import sys
import signal

#exit_on_signal()                   # Install C++ debugging traceback

# ----------------------------------------------------------------------------------------------------------
# Types (functions are used to replace the "constructors" due to an issue with SWIG replacing __new__)
# ----------------------------------------------------------------------------------------------------------

ExprType = Expr
ParamTypes = (Param_int8, Param_int16, Param_int32, Param_uint8, Param_uint16, Param_uint32, Param_float32, Param_float64)
RDomType = RDom
ImageTypes = (Image_int8, Image_int16, Image_int32, Image_uint8, Image_uint16, Image_uint32, Image_float32, Image_float64)
ImageParamType = ImageParam

# ----------------------------------------------------
# Expr
# ----------------------------------------------------

def wrap(*a):
#    print a
    if len(a) == 1:
        if isinstance(a[0], ParamTypes):
            return cast_to_expr(a[0])
        elif isinstance(a[0], ImageTypes):# or isinstance(a[0], DynImageType):
            return a[0] #ExprType(to_dynimage(a[0]))
        elif isinstance(a[0], (int,long)):
            return cast_to_expr(a[0])
        elif isinstance(a[0], tuple):
            raise ValueError('tuple syntactic sugar not supported -- use select() instead')
        else:
            return cast_to_expr(a[0])
            #return expr_from_tuple(*(wrap(x) for x in a[0]))
    return ExprType(*a)
    
in_filename = '../apps/images/rgb.png'
    
pow0 = pow

for BaseT in (Expr, FuncRefExpr, FuncRefVar, Var, RDom, RVar, Func) + ParamTypes:
    BaseT.__add__ = lambda x, y: add(wrap(x), wrap(y))
    BaseT.__sub__ = lambda x, y: sub(wrap(x), wrap(y))
    BaseT.__mul__ = lambda x, y: mul(wrap(x), wrap(y))
    BaseT.__div__ = lambda x, y: div(wrap(x), wrap(y))
    BaseT.__mod__ = lambda x, y: mod(wrap(x), wrap(y))
    BaseT.__pow__ = lambda x, y: pow0(wrap(x), wrap(y))
    BaseT.__and__  = lambda x, y: and_op(wrap(x), wrap(y))
    BaseT.__or__  = lambda x, y: or_op(wrap(x), wrap(y))

    BaseT.__radd__ = lambda y, x: add(wrap(x), wrap(y))
    BaseT.__rsub__ = lambda y, x: sub(wrap(x), wrap(y))
    BaseT.__rmul__ = lambda y, x: mul(wrap(x), wrap(y))
    BaseT.__rdiv__ = lambda y, x: div(wrap(x), wrap(y))
    BaseT.__rmod__ = lambda y, x: mod(wrap(x), wrap(y))
    BaseT.__rpow__ = lambda y, x: pow(wrap(x), wrap(y))
    BaseT.__rand__  = lambda y, x: and_op(wrap(x), wrap(y))
    BaseT.__ror__  = lambda y, x: or_op(wrap(x), wrap(y))

    BaseT.__neg__ = lambda x: neg(wrap(x))
    BaseT.__invert__  = lambda x: invert(wrap(x))

    BaseT.__lt__  = lambda x, y: lt(wrap(x), wrap(y))
    BaseT.__le__  = lambda x, y: le(wrap(x), wrap(y))
    BaseT.__eq__  = lambda x, y: eq(wrap(x), wrap(y))
    BaseT.__ne__  = lambda x, y: ne(wrap(x), wrap(y))
    BaseT.__gt__  = lambda x, y: gt(wrap(x), wrap(y))
    BaseT.__ge__  = lambda x, y: ge(wrap(x), wrap(y))

    BaseT.__iadd__ = lambda x, y: iadd(wrap(x), wrap(y))
    BaseT.__isub__ = lambda x, y: isub(wrap(x), wrap(y))
    BaseT.__imul__ = lambda x, y: imul(wrap(x), wrap(y))
    BaseT.__idiv__ = lambda x, y: idiv(wrap(x), wrap(y))

# ----------------------------------------------------
# RDom
# ----------------------------------------------------

def RDom(*args):
    args = [wrap(x) if not isinstance(x,str) else x for x in args]
    return RDomType(*args)

# ----------------------------------------------------
# Var, Func
# ----------------------------------------------------

for C in [Var, FuncRefExpr, FuncRefVar]:
    C.__add__ = lambda x, y: add(wrap(x), wrap(y))
    C.__sub__ = lambda x, y: sub(wrap(x), wrap(y))
    C.__mul__ = lambda x, y: mul(wrap(x), wrap(y))
    C.__div__ = lambda x, y: div(wrap(x), wrap(y))
    C.__mod__ = lambda x, y: mod(wrap(x), wrap(y))
    C.__pow__ = lambda x, y: pow(wrap(x), wrap(y))
    C.__and__  = lambda x, y: and_op(wrap(x), wrap(y))
    C.__or__  = lambda x, y: or_op(wrap(x), wrap(y))

    C.__neg__ = lambda x: neg(wrap(x))
    C.__invert__  = lambda x: invert(wrap(x))

    C.__lt__  = lambda x, y: lt(wrap(x), wrap(y))
    C.__le__  = lambda x, y: le(wrap(x), wrap(y))
    C.__eq__  = lambda x, y: eq(wrap(x), wrap(y))
    C.__ne__  = lambda x, y: ne(wrap(x), wrap(y))
    C.__gt__  = lambda x, y: gt(wrap(x), wrap(y))
    C.__ge__  = lambda x, y: ge(wrap(x), wrap(y))

# ----------------------------------------------------
# Func
# ----------------------------------------------------

def raise_error(e):
    raise e

#_reset0 = Func.reset     # Reset schedule has been removed (could be reimplemented in C++ layer as a walk over all Funcs)
_split0 = Func.split
_tile0 = Func.tile
_reorder0 = Func.reorder
_bound0 = Func.bound

_generic_getitem_var_or_expr = lambda x, key: call(x, *wrap_func_args(key)) if isinstance(key,tuple) else call(x, wrap(key) if not isinstance(key,Var) else key)
_generic_getitem_expr = lambda x, key: call(x, *[wrap(y) for y in key]) if isinstance(key,tuple) else call(x, wrap(key))
_generic_set = lambda x, y: set(x, wrap(y))
#_realize = Func.realize

Func.__call__ = lambda self, *L: raise_error(ValueError('used f(x, y) to refer to a Func -- proper syntax is f[x, y]'))
def wrap_func_args(args):
    if all(isinstance(x, Var) for x in args):
        return args
    return [wrap(y) for y in args]
    
Func.__setitem__ = lambda x, key, value: set(call(x, *wrap_func_args(key)), wrap(value)) if isinstance(key,tuple) else set(call(x, wrap(key) if not isinstance(key,Var) else key), wrap(value))
Func.__getitem__ = _generic_getitem_var_or_expr
Func.set = _generic_set
#Func.realize = lambda x, *a: _realize(x,*a) if not (len(a)==1 and isinstance(a[0], ImageTypes)) else _realize(x,to_dynimage(a[0]))
Func.split = lambda self, a, b, c, d: _split0(self, a, b, c, wrap(d))
Func.tile = lambda self, *a: _tile0(self, *[a[i] if i < len(a)-2 else wrap(a[i]) for i in range(len(a))])
Func.reorder = lambda self, *a: _reorder0(self, ListVar(a))
Func.bound = lambda self, a, b, c: _bound0(self, a, wrap(b), wrap(c))

# ----------------------------------------------------
# FuncRef
# ----------------------------------------------------

#FuncRef.__mul__ = lambda x, y: mul(wrap(x), wrap(y))
#FuncRef.__rmul__ = lambda x, y: mul(wrap(x), wrap(y))

# ----------------------------------------------------
# Image
# ----------------------------------------------------

# Halide examples use f[x,y] convention -- flip to I[y,x] convention when converting Halide <=> numpy
flip_xy = True

def image_getattr(self, name):
    if name == '__array_interface__':
        #print 'get array'
        D = self #DynImage(self)
        t = D.type()
        if t.is_int():
            typestr = '|i%d'%(t.bits/8)
        elif t.is_uint():
            typestr = '|u%d'%(t.bits/8)
        elif t.is_float():
            typestr = '|f%d'%(t.bits/8)
        else:
            raise ValueError('Unknown type %r'%t)
        shape = tuple([D.extent(i) for i in range(D.dimensions())])
        strides = tuple([D.stride(i)*(t.bits/8) for i in range(D.dimensions())])
        if flip_xy and len(strides) >= 2:
            strides = (strides[1], strides[0]) + strides[2:]
            shape = (shape[1], shape[0]) + shape[2:]
        data = image_to_string(self)
        return {'shape': shape,
                'typestr': typestr,
                'data': data,
                'strides': strides}
    raise AttributeError(name)

for _ImageT in ImageTypes:
    _ImageT.__getitem__ = _generic_getitem_expr

Image_int8.type = lambda x: Int(8)
Image_int16.type = lambda x: Int(16)
Image_int32.type = lambda x: Int(32)
Image_uint8.type = lambda x: UInt(8)
Image_uint16.type = lambda x: UInt(16)
Image_uint32.type = lambda x: UInt(32)
Image_float32.type = lambda x: Float(32)
Image_float64.type = lambda x: Float(64)

def show_image(I, maxval=None):
    "Shows an Image instance on the screen, by converting through numpy and PIL."
    A = numpy.asarray(I)
    if maxval is not None:
        A = numpy.asarray(A,'float32')*(1.0/maxval)
  #  print 'converted to numpy', A.dtype
    if A.dtype == numpy.uint8:
        pass
    elif A.dtype == numpy.uint16: #numpy.issubdtype(A.dtype, 'uint16'):
        A = numpy.array(A/256, 'uint8')
    elif A.dtype == numpy.uint32: #numpy.issubdtype(A.dtype, 'uint32'):
        A = numpy.array(A/256**3, 'uint8')
    elif A.dtype == numpy.float32 or A.dtype == numpy.float64: #numpy.issubdtype(A.dtype, 'float32') or numpy.issubdtype(A.dtype, 'float64'):
        A = numpy.array(A*255.0, 'uint8')
    else:
        raise ValueError('Unsupported dtype %r' % A.dtype)
    if len(A.shape) == 3 and A.shape[2] == 1:
        A = A[:,:,0]
    PIL.fromarray(A).show()
    
for _ImageT in ImageTypes:
    _ImageT.save = lambda x, y: save_png(x, y)
    _ImageT.set = _generic_set
    _ImageT.__getattr__ = image_getattr
    _ImageT.show = lambda *args: show_image(*args)

def _image_from_numpy(a):
    a = numpy.asarray(a)
    shape = a.shape
    strides = a.strides
    if flip_xy and len(shape) >= 2:
        shape = (shape[1], shape[0]) + shape[2:]
        strides = (strides[1], strides[0]) + strides[2:]
        
    d = {numpy.dtype('int8'): Image_int8,
         numpy.dtype('int16'): Image_int16,
         numpy.dtype('int32'): Image_int32,
         numpy.dtype('uint8'): Image_uint8,
         numpy.dtype('uint16'): Image_uint16,
         numpy.dtype('uint32'): Image_uint32,
         numpy.dtype('float32'): Image_float32,
         numpy.dtype('float64'): Image_float64}

    if a.dtype in d:
        C = d[a.dtype]
    else:
        raise TypeError('No Image constructor for numpy.%r'%a.dtype)
    
    ans = C(*shape)
    assign_array(ans, a.__array_interface__['data'][0], *strides)
    return ans
    
def Image(typeval, *args):
    """
    Constructors:
    Image(typeval),    typeval=Int(n), UInt(n), Float(n), Bool()
    Image(typeval, filename, [maxval])     -- Loads via Python Image Library, uses max value of maxval
    Image(typeval, nsize)
    Image(typeval, w, h)
    Image(typeval, w, h, nchan)
    ...
    Image(typeval, Image_int8|Image_int16|...)
    Image(typeval, ImageParam)
    Image(numpy_array)
    Image(buffer)
    """
    
    if len(args) == 0:
        if hasattr(typeval, '__len__'):
            if isinstance(typeval, (str, unicode)):
                raise ValueError('to build image from PNG/PPM use constructor Image(typeval, filename), e.g. Image(UInt(8), filename)')
            return _image_from_numpy(typeval)
        elif isinstance(typeval, Buffer):
            args = (typeval,)
            typeval = typeval.type()             
            
    assert isinstance(typeval, Type)
    sig = (typeval.bits, typeval.is_int(), typeval.is_uint(), typeval.is_float())
    
    if sig == (8, True, False, False):
        C = Image_int8
        target_dtype = 'int8'
    elif sig == (16, True, False, False):
        C = Image_int16
        target_dtype = 'int16'
    elif sig == (32, True, False, False):
        C = Image_int32
        target_dtype = 'int32'
    elif sig == (8, False, True, False):
        C = Image_uint8
        target_dtype = 'uint8'
    elif sig == (16, False, True, False):
        C = Image_uint16
        target_dtype = 'uint16'
    elif sig == (32, False, True, False):
        C = Image_uint32
        target_dtype = 'uint32'
    elif sig == (32, False, False, True):
        C = Image_float32
        target_dtype = 'float32'
    elif sig == (64, False, False, True):
        C = Image_float64
        target_dtype = 'float64'
    else:
        raise ValueError('unimplemented Image type signature %r' % typeval)
    if len(args) == 0:
        return C
    elif len(args) in [1,2] and isinstance(args[0], str):
        #return load_png(C(1), args[0])     # load_png() seems broken so use PIL conversion instead
        I = numpy.asarray(PIL.open(args[0]))
        in_range = 255
        if len(args) == 2:
            out_range = args[1]
        else:
            out_range = typeval.maxval()
        if in_range != out_range:
            return Image(numpy.asarray(numpy.asarray(I,float)*(1.0*out_range/in_range), target_dtype))
        else:
            return Image(numpy.asarray(I, target_dtype))
    elif all(isinstance(x, int) for x in args):
        return C(*args)
    elif len(args) == 1 and isinstance(args[0], ImageTypes+(ImageParamType,)+(Buffer,)):
        return C(*args)
    else:
        raise ValueError('unknown Image constructor arguments %r' % args)

# ----------------------------------------------------
# Param
# ----------------------------------------------------

def Param(typeval, *args):
    assert isinstance(typeval, Type)
    sig = (typeval.bits, typeval.is_int(), typeval.is_uint(), typeval.is_float())
    if sig == (8, True, False, False):
        C = Param_int8
    elif sig == (16, True, False, False):
        C = Param_int16
    elif sig == (32, True, False, False):
        C = Param_int32
    elif sig == (8, False, True, False):
        C = Param_uint8
    elif sig == (16, False, True, False):
        C = Param_uint16
    elif sig == (32, False, True, False):
        C = Param_uint32
    elif sig == (32, False, False, True):
        C = Param_float32
    elif sig == (64, False, False, True):
        C = Param_float64
    else:
        raise ValueError('unimplemented Param type signature %r' % typeval)
    if len(args) == 1:          # Handle special cases since SWIG apparently cannot convert int32_t to int.
        if isinstance(args[0], (int, float)):
            ans = C()
            set(ans, args[0])
            return ans
    elif len(args) == 2:
        if isinstance(args[1], (int, float)):
            ans = C(args[0])
            set(ans, args[1])
            return ans
    return C(*args)

for ParamT in ParamTypes: # + (DynUniform,):
    ParamT.set = lambda x, y: set(x, y) #_generic_assign

# ----------------------------------------------------
# Various image types
# ----------------------------------------------------

#UniformImage.__setitem__ = lambda x, key, value: assign(call(x, *[wrap(y) for y in key]), wrap(value)) if isinstance(key,tuple) else assign(call(x, key), wrap(value))

for _ImageT in [ImageParam]:
    _ImageT.__getitem__ = _generic_getitem_expr
    _ImageT.set = lambda x, y: set(x, Image(y) if isinstance(y,numpy.ndarray) else y)
    #_ImageT.save = lambda x, y: save_png(x, y)

# ----------------------------------------------------
# Type
# ----------------------------------------------------

def _type_maxval(typeval):          # The typical maximum value used for image processing (1.0 for float types)
    if typeval.is_uint():
        return 2**(typeval.bits)-1
    elif typeval.is_int():
        return 2**(typeval.bits-1)-1
    elif typeval.is_float():
        return 1.0
    else:
        raise ValueError('unknown typeval %r'%typeval)

def _type_to_numpy(typeval):
    if typeval.is_int():
        return numpy.dtype('int%d'%typeval.bits)
    elif typeval.is_uint():
        return numpy.dtype('uint%d'%typeval.bits)
    elif typeval.is_float():
        return numpy.dtype('float%d'%typeval.bits)
    else:
        raise ValueError('unknown type %r'%typeval)

Type.maxval = _type_maxval
Type.to_numpy = _type_to_numpy

# ----------------------------------------------------
# Repr
# ----------------------------------------------------

Var.__repr__ = lambda self: 'Var(%r)'%self.name()
Type.__repr__ = lambda self: 'UInt(%d)'%self.bits if self.is_uint() else 'Int(%d)'%self.bits if self.is_int() else 'Float(%d)'%self.bits if self.is_float() else 'Type(%d)'%self.bits 
Expr.__repr__ = lambda self: 'Expr(%s)' % ', '.join([repr(self.type())]) #  + [str(_x) for _x in self.vars()]
Func.__repr__ = lambda self: 'Func(%r)' % self.name()

# ----------------------------------------------------
# Global functions
# ----------------------------------------------------

# Wrap unary math functions

for _funcname in 'sqrt sin cos exp log floor ceil round asin acos atan tan sinh asinh cosh acosh tanh atanh fast_log fast_exp abs'.split():
    exec "_%s = %s" % (_funcname, _funcname)
    exec "%s = lambda x: _%s(wrap(x))" % (_funcname, _funcname)

# Wrap binary math functions
for _funcname in 'max min hypot fast_pow'.split():
    exec "_%s = %s" % (_funcname, _funcname)
    exec "%s = lambda x, y: _%s(wrap(x), wrap(y))" % (_funcname, _funcname)
    
#_debug = debug         # Debug node was removed from C++ layer
#debug  = lambda x, y, *a: _debug(wrap(x), y, *a)

_max = max
_min = min
_clamp = clamp
_cast = cast
_select = select

pow    = lambda x, y: wrap(x)**wrap(y)

max    = lambda x, y: _max(wrap(x), wrap(y))
min    = lambda x, y: _min(wrap(x), wrap(y))
clamp  = lambda x, y, z: _clamp(wrap(x), wrap(y), wrap(z))
cast   = lambda x, y: _cast(x, wrap(y))
select = lambda x, y, z: _select(wrap(x), wrap(y), wrap(z))

minimum = lambda x: minimum_func(wrap(x))
maximum = lambda x: maximum_func(wrap(x))
product = lambda x: product_func(wrap(x))
sum     = lambda x: sum_func(wrap(x))

# ----------------------------------------------------
# Constructors
# ----------------------------------------------------

Expr = wrap

# ----------------------------------------------------
# Test
# ----------------------------------------------------

import time

def test_core():
    input = ImageParam(UInt(16),2)
    var_x = Var('x')
    var_y = Var('y')
    blur_x = Func('blur_x')
    blur_y = Func('blur_y')
    expr_x = Expr(var_x)
    #print expr_x
    expr_y = Expr(var_y)
    #Expr(x) + Expr(y)

    T0 = time.time()
    n = 1

    def check(L):
        for x in L:
            assert isinstance(x, ExprType), x

    for i in range(n):
        for x in [expr_x, var_x, 1, 1.3]:
            for y in [expr_y, var_y, 1, 1.3]:
                if isinstance(x, (int,float)) and isinstance(y, (int, float)):
                    continue
                #print type(x), type(y)
                check([x + y,
                x - y,
                x * y,
                x / y,
                x % y,
                x < y,
                x <= y,
                x == y,
                x != y,
                x > y,
                x >= y,
                -x] + [cast(Bool(), x) & cast(Bool(), y),
                cast(Bool(), x) | cast(Bool(), y)] + [~cast(Bool(), x)] if not isinstance(x, (int, float)) else [])

                if isinstance(x, ExprType):
                    x += y
                    check([x])
                    x -= y
                    check([x])
                    x *= y
                    check([x])
                    x /= y
                    check([x])
        
    #blur_x += expr_x
    #blur_x(expr_x)

    T1 = time.time()

    x = var_x
    y = var_y
    z = Var()
    q = Var()
    
    assert isinstance(x+1, ExprType)
    assert isinstance(x/y, ExprType)
    assert isinstance((x/y)+(x-1), ExprType)
    assert isinstance(blur_x[x-1,y], FuncRefExpr)
    assert isinstance(blur_x[x, y], FuncRefVar)
    assert isinstance(blur_x[x-1], FuncRefExpr)
    assert isinstance(blur_x[x-1,y,z], FuncRefExpr)
    assert isinstance(blur_x[x-1,y,z,q], FuncRefExpr)
    f = Func()
    f[x,y]=x+1
    
    print 'halide.test_core:                    OK'
  
def func_varlist(f):
    return [x for x in f.function().args()]

def get_blur():
    input = ImageParam(UInt(16), 3, 'input')
    x = Var('x')
    y = Var('y')
    c = Var('c')
    input_clamped = Func('input_clamped')
    blur_x = Func('blur_x')
    blur_y = Func('blur_y')

    input_clamped[x,y,c] = input[clamp(Expr(x),cast(Int(32),Expr(0)),cast(Int(32),Expr(input.width()-1))),
                                 clamp(Expr(y),cast(Int(32),Expr(0)),cast(Int(32),Expr(input.height()-1))),
                                 c] #clamp(Expr(c),Expr(0),Expr(input.width()-1))]
    blur_x[x,y,c] = (input_clamped[x-1,y,c]/4+input_clamped[x,y,c]/4+input_clamped[x+1,y,c]/4)/3
    blur_y[x,y,c] = (blur_x[x,y-1,c]+blur_x[x,y,c]+blur_x[x,y+1,c])/3*4
    return (input, x, y, c, blur_x, blur_y, input_clamped)

def roundup_multiple(x, y):
    return (x+y-1)/y*y

def inputs_dir():
    "Get directory of example inputs."
    return os.path.abspath(os.path.join(os.path.dirname(__file__), '../apps/images'))
    
def filter_image(input, out_func, in_image, disp_time=False, compile=True, eval_func=None, out_dims=None, times=1): #, pad_multiple=1):
    """
    Utility function to filter an image filename or numpy array with a Halide Func, returning output Image of the same size.
    
    Given input and output Funcs, and filename/numpy array (in_image), returns evaluate. Calling evaluate() returns the output Image.
    """
#    print 'filter_image, input=', input, 'dtype', input.type()
    dtype = input.type()
    if isinstance(input, ImageParamType):
        if isinstance(in_image, str):
            input_png = Image(dtype, in_image)
        elif isinstance(in_image, numpy.ndarray):
            input_png = Image(in_image)
        else:
            input_png = in_image
        input.set(input_png)
    else:
        input_png = input

    w = input_png.width() if out_dims is None else out_dims[0]
    h = input_png.height() if out_dims is None else out_dims[1]
    nchan = input_png.channels() if out_dims is None else (out_dims[2] if len(out_dims) >= 3 else 1)
    #print w, h, nchan, out_dims
    if compile:
        out_func.compile_jit()

    def evaluate():
        T = []
        for i in range(times):
            T0 = time.time()
            if eval_func is not None:
                realized = eval_func(input_png)
            else:
                if nchan != 1:
                    realized = out_func.realize(w, h, nchan)
                else:
                    realized = out_func.realize(w, h)
            T.append(time.time()-T0)
        out = Image(realized) #.set(realized)
        
        if nchan != 1:
            assert out.width() == w and out.height() == h and out.channels() == nchan, (out.width(), out.height(), out.channels(), w, h, nchan)
        else:
            assert out.width() == w and out.height() == h, (out.width(), out.height(), w, h)
        if disp_time:
            if times > 1:
                print 'Filtered %d times, min: %.6f secs, mean: %.6f secs.' % (times, numpy.min(T), numpy.mean(T))
            else:
                print 'Filtered in %.6f secs' % T[0]
                
        return out
    return evaluate

# -------------------------------------------------------------------------------------------
# Unit Tests
# -------------------------------------------------------------------------------------------

def example_out():
    (input, x, y, c, blur_x, blur_y, input_clamped) = get_blur()

    blur_y.unroll(y,16).vectorize(x,16)
    blur_y.compile_jit()

    return filter_image(input, blur_y, in_filename)()

def test_blur():
    (input, x, y, c, blur_x, blur_y, input_clamped) = get_blur()
    
    for f in [blur_y, blur_x]:
        assert len(f.function().args()) == 3
        assert f.function().args()[0]=='x'
        assert f.function().args()[1]=='y'
        assert f.function().args()[2]=='c'
    #assert blur_y.value().funcs()[0].name()=='blur_x'
    str(blur_y.value())

    #assert len(blur_y.value().funcs()) == 1, list(blur_y.value().funcs())
    #assert set(all_funcs(blur_y).keys()) == set(['blur_x', 'blur_y', 'input_clamped']), set(all_funcs(blur_y).keys())
    assert func_varlist(blur_y) == ['x', 'y', 'c'], func_varlist(blur_y)
    assert func_varlist(blur_x) == ['x', 'y', 'c'], func_varlist(blur_x)
    
    for i in range(2):
        input_arg = Argument('input', True, UInt(16))
        blur_y.compile_to_file('halide_blur', input_arg)
#        blur_y.compile_to_file('halide_blur', [input_arg])

        outf = filter_image(input, blur_y, in_filename)
        T0 = time.time()
        out = outf()
        T1 = time.time()
        #print T1-T0, 'secs'
    
        out_filename = 'test_out.png'
        out.save(out_filename)
        s = image_to_string(out)
        assert isinstance(s, str)
        I1 = numpy.asarray(PIL.open(out_filename))
        os.remove(out_filename)
    
    print 'halide.test_blur:                    OK'

def test_func(compile=True, in_image=in_filename):
    (input, x, y, c, blur_x, blur_y, input_clamped) = get_blur()

    outf = filter_image(input, blur_y, in_image, compile=compile)
    out = [None]
    
    def test(func):
        T0 = time.time()
        out[0] = outf()
        T1 = time.time()
        return T1-T0
    
    return locals()

def test_segfault():
    locals_d = test_func(compile=False)
    x = locals_d['x']
    y = locals_d['y']
    c = locals_d['c']
    blur_y = locals_d['blur_y']
    test = locals_d['test']
    
    exit_on_signal()
    # TODO: Implement a test that segfaults...
    
def test_examples():
    import examples
    in_grayscale = 'lena_crop_grayscale.png'
    in_color = 'lena_crop.png'
    
    names = []
    do_filter = True
    
#    for example_name in ['interpolate']: #
    for example_name in 'interpolate blur dilate boxblur_sat boxblur_cumsum local_laplacian'.split(): #[examples.snake, examples.blur, examples.dilate, examples.boxblur_sat, examples.boxblur_cumsum, examples.local_laplacian]:
#    for example_name in 'interpolate blur dilate boxblur_sat boxblur_cumsum local_laplacian snake'.split(): #[examples.snake, examples.blur, examples.dilate, examples.boxblur_sat, examples.boxblur_cumsum, examples.local_laplacian]:
#    for example_name in 'interpolate snake blur dilate boxblur_sat boxblur_cumsum local_laplacian'.split(): #[examples.snake, examples.blur, examples.dilate, examples.boxblur_sat, examples.boxblur_cumsum, examples.local_laplacian]:
        example = getattr(examples, example_name)
        first = True
#    for example in [examples.boxblur_cumsum]:
        for input_image0 in [in_grayscale, in_color]:
            for dtype in [UInt(8), UInt(16), UInt(32), Float(32), Float(64)]:
                input_image = input_image0
#            for dtype in [UInt(16)]:
#            for dtype in [UInt(8), UInt(16)]:
                if example is examples.boxblur_sat or example is examples.boxblur_cumsum:
                    if dtype == UInt(32):
                        continue
                if example is examples.local_laplacian:
                    if input_image == in_color and (dtype == UInt(8) or dtype == UInt(16)):
                        pass
                    else:
                        continue
                if example is examples.snake:
                    if dtype != UInt(8) or input_image != in_color:
                        continue
                #print dtype.isFloat(), dtype.bits
                if example is examples.interpolate:
                    if not dtype.isFloat() or input_image != in_color:
                        continue
                    input_image = 'interpolate_in.png'
        #        (in_func, out_func) = examples.blur_color(dtype)
    #            (in_func, out_func) = examples.blur(dtype)
                (in_func, out_func, eval_func, scope) = example(dtype)
                if first:
                    first = False
                    names.append(example_name)
        #        print 'got func'
        #        outf = filter_image(in_func, out_func, in_filename, dtype)
        #        print 'got filter'
                if do_filter:
                    outf = filter_image(in_func, out_func, input_image, disp_time=True, eval_func=eval_func)
                    out = outf()
                    out.show()
                    A = numpy.asarray(out)
        #        print 'shown'
#                print numpy.min(A.flatten()), numpy.max(A.flatten())
        #        out.save('out.png')
#    print
#    print 'Function names:'
#    for (example_name, func_names) in names:
#        print example_name, func_names

def test_numpy():
    def dist(a,b):
        a = numpy.asarray(a, 'float64') - numpy.asarray(b, 'float64')
        a = a.flatten()
        return numpy.mean(numpy.abs(a))

    for dtype in [UInt(8), UInt(16), UInt(32), Float(32), Float(64)]:
        for mul in [0, 1]:
            a = numpy.asarray(Image(dtype, in_filename))*mul
            b = Image(a)
            c = numpy.asarray(b)
            assert a.dtype == c.dtype
            assert dist(a,c) < 1e-8

            if dtype == UInt(16):
                locals_d = test_func(in_image=a)
                test = locals_d['test']
                blur_y = locals_d['blur_y']
                out = locals_d['out']
                test(blur_y)
                c = numpy.asarray(out[0])
                assert dist(a,c)<=1500, dist(a,c)

    print 'halide.test_numpy:                   OK'

def test_minimal():
    f1 = Func()
    f2 = Func()
    f3 = Func()
    f4 = Func()
    x = Var()
    y = Var()
    z = Var()
    w = Var()
    f1[x] = 1.0
    f2[x,y] = x
    f3[x,y,z] = y
    f4[x,y,z,w] = 1.0
    print 'halide.test_minimal:                 OK'

def test():
    exit_on_signal()

    test_minimal()
    test_numpy()
    test_blur()
    test_core()
    
if __name__ == '__main__':
    test()
    
