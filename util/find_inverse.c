#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <assert.h>

void test(int x, int y, int shift1, int shift2, int *too_big, int *too_small) {
    for (int n = 0; n < 65536; n++) {
	int correct = n / x;
	int result = int(((size_t)n * y) >> 16);
	result = (result + ((n - result) >> shift1)) >> shift2;
	if (result > correct) {
	    printf("%d / %d != %d\n", n, x, result);
	    too_big[0]++;
	} else if (result < correct) {
	    printf("%d / %d != %d\n", n, x, result);
	    too_small[0]++;
	}
    }
}

uint16_t u_div(uint16_t num, uint16_t den) {
    int bits = 0;
    for (int i = 1; i < den; i*=2) bits++;
    uint16_t m = (1 << (16+bits)) / den - (1 << 16) + 1;
    int sh1 = bits < 1 ? bits : 1;
    int sh2 = bits - sh1;

    uint16_t mul = ((uint32_t)num * (uint32_t)m) >> 16;
    return (mul + ((num - mul) >> sh1)) >> sh2;
}

void choose_multiplier(int d, int prec, int *mul, int *shift, int *l) {
    int bits = 0;
    for (int i = 1; i < d; i*=2) bits++;
    int sh = bits;
    int m_lo = (1 << (16 + bits)) / d;
    int m_hi = ((1 << (16 + bits)) + (1 << (16 + bits - prec)))/d;
    while (m_lo/2 < m_hi/2 && sh > 0) {
	m_lo /= 2;
	m_hi /= 2;
	sh--;
    }
    *l = bits;
    *mul = m_hi;
    *shift = sh;
}

uint16_t u_div2(uint16_t n, uint16_t d) {
    int d_odd, t_1, m, e, l, l_dummy, sh_post, sh_pre;
    int N = 16;
    choose_multiplier(d, N, &m, &sh_post, &l);
    
    if (m >= (1 << N) && ((d & 1) == 0)) {
	e = 0;
	d_odd = d;
	while (d_odd & 1) {
	    e++;
	    d_odd /= 2;	    
	}
	sh_pre = e;
	choose_multiplier(d_odd, N-e, &m, &sh_post, &l);
    } else {
	sh_pre = 0;
    }

    printf("m = %d\n", m);
    
    if (d == (1 << l)) {	
	printf("power of two\n");
	return n >> l;
    } else if (m >= (1 << N)) {
	printf("complex case\n");
	assert(sh_pre == 0);
	t_1 = ((m - (1<<N)) * n) >> N;
	return (t_1 + ((n - t_1) >> 1)) >> (sh_post - 1);
    } else {
	printf("simple case %d %d %d\n", m, sh_pre, sh_post);
	t_1 = (m * (n >> sh_pre)) >> 16;
	return t_1 >> sh_post;
    }
}

bool u_method_0(int den, int sh_post, int bits) {
    int max = (1 << bits) - 1;
    for (int num = 0; num <= max; num++) {	
	uint64_t result = num;
	result >>= sh_post;
	if (num / den != result) return false;
    }
    return true;
}

bool u_method_1(int den, int mul, int sh_post, int bits) {
    int max = (1 << bits) - 1;
    for (int num = 0; num <= max; num++) {
	uint64_t result = num;
	result *= mul;
	result >>= bits;
	if (result > max) return false;
	result >>= sh_post;
	if (num / den != result) return false;
    }
    return true;
}

bool u_method_2(int den, int mul, int sh_post, int bits) {
    int max = (1 << bits) - 1;
    for (int num = 0; num <= max; num++) {
	uint64_t result = num;
	result *= mul;
	result >>= bits;
	if (result > max) return false;
	result += (num - result)/2;
	if (result > max) return false;
	result >>= sh_post;
	if (num / den != result) return false;
    }
    return true;    
}


bool s_method_0(int den, int mul, int sh_post, int bits) {
    int min = -(1 << (bits-1)), max = (1 << (bits-1))-1;
    for (int num = min; num <= max; num++) {
	int64_t result = num;
	result *= mul;
	result >>= bits;
	if (result > max || result < min) return false;
	result >>= sh_post;
	result += (num < 0 ? 1 : 0);
	if (num / den != result) return false;
    }
    return true;
}

bool s_method_1(int den, int mul, int sh_post, int bits) {
    int min = -(1 << (bits-1)), max = (1 << (bits-1))-1;
    for (int num = min; num <= max; num++) {
	int64_t result = num;
	result *= mul;
	result >>= bits;
	if (result > max || result < min) return false;
	result += num;
	if (result > max || result < min) return false;
	result >>= sh_post;
	result += (num < 0 ? 1 : 0);
	if (num / den != result) return false;
    }
    return true;    
}


int main(int argc, char **argv) {
    /* This program computes a table to help us do cheap integer
        division by a constant. It is based on the paper "Division by
        Invariant Integers using Multiplication" by Granlund and
        Montgomery.
    */

    printf("(* Generated by util/find_inverse.c *)\n");

    for (int bits = 8; bits <= 16; bits += 8) {
	int s_min = -(1 << (bits-1));
	int s_max = (1 << (bits-1))-1;
	int u_max = (1 << bits)-1;
   	
	printf("let table_u%d = [|\n", bits);
	for (int den = 2; den <= 64; den++) {
	    for (int shift = 0; shift < 8; shift++) {
		if (u_method_0(den, shift, bits)) {
		    printf("  (0, 0, %d);\n", shift);
		    goto next_unsigned;
		}
	    }
	    
	    for (int shift = 0; shift < 8; shift++) {
		for (int mul = 0; mul <= u_max; mul++) {
		    if (u_method_1(den, mul, shift, bits)) {
			printf("  (1, %d, %d);\n", mul, shift);
			goto next_unsigned;
		    }
		}
	    }
	    
	    for (int shift = 0; shift < 8; shift++) {
		for (int mul = 0; mul <= u_max; mul++) {
		    if (u_method_2(den, mul, shift, bits)) {
			printf("  (2, %d, %d);\n", mul, shift);
			goto next_unsigned;
		    }
		}
	    }
	    printf("ERROR! No solution found for unsigned %d\n", den);
	  next_unsigned:;
	}
	printf("|]\n");
	printf("let table_s%d = [|\n", bits);
	for (int den = 2; den <= 64; den++) {

	    for (int shift = 0; shift < 8; shift++) {
		for (int mul = s_min; mul <= s_max; mul++) {
		    if (s_method_0(den, mul, shift, bits)) {
			printf("  (0, %d, %d);\n", mul, shift);
			goto next_signed;
		    }
		}
	    }
	    
	    for (int shift = 0; shift < 8; shift++) {
		for (int mul = s_min; mul <= s_max; mul++) {
		    if (s_method_1(den, mul, shift, bits)) {
			printf("  (1, %d, %d);\n", mul, shift);
			goto next_signed;
		    }
		}
	    }
	    printf("ERROR! No solution found for signed %d\n", den);
	  next_signed:;
	}
	printf("|]\n");
    }


    return 0;
}
